# HashMap源码分析总结

由于没有亲自去分析源码，故到网上找了一篇整理的很详细的文章阅读（[点我跳转](https://juejin.im/post/6844903570475597837)）了，先记住结论：

关于HashMap的源码分析，给出以下几点重要的总结：
  1.从结构上我们可以知道，从JDK1.8开始，HashMap是数组+链表+红黑树实现的。而JDK1.7 HashMap的数据结构是数组+链表。做法是：当链表长度>8时，便将链表转换成红黑树。而引入红黑树，提高了HashMap的性能，因为这样可以解决哈希碰撞后链表过长而导致的索引效率慢的问题，这主要是利用了红黑树的快速增删改查的特点。
  2.HashMap共有四个构造方法。构造方法中都提到了两个很重要的参数：初始容量（initialCapacity）和加载因子（loadFactor）。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希表的长度），初始容量是创建哈希表时的容量（从构造方法中可以看出，如果不指明，默认是16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积（即扩容阈值threshold）时，就要对该哈希表进行扩容（resize）操作。
  3.HashMap工作原理：通过hash的方法，以及put和get存储和获取对象。存储对象时，我们首先将K/V传给put方法，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在JDK1.8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。
  4.关于加载因子：加载因子是可以修改的。如果加载因子越大，填满的元素会越多，对空间的利用更充分，但是冲突的概率加大，链表变长，查找效率会降低；如果加载因子越小，那么冲突概率减小，链表变短，查找效率变高，但是填满空间会越少，会造成很多空间还没利用便开始扩容，对空间造成严重浪费，而且频繁的扩容会消耗性能。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况我们不建议修改。
  5.关于扩容：扩容是一个相当耗性能的操作，因为需要重新计算元素在新的数组中的位置并进行复制处理。我们知道Java里的数组是无法自动扩容的，在通过源码分析resize()方法中，我们了解到HashMap便是使用一个容量更大的数组来代替已有的容量小的数组。新容量是原有容量的2倍。然后遍历旧数组的元素，重新计算出每个元素在新数组的存储位置，最后将旧数组的每个元素逐个转移到新数组中。所以，我们在用HashMap时，最好能提前预估HashMap中的元素个数，这样有助于提高HashMap的性能。
  6.HashMap是线程不安全的，其中一个重要原因是：多线程下容易出现resize（）死循环，其本质是并发执行的put（）操作导致触发扩容行为，从而导致环形链表，使得在获取数据遍历链表时形成死循环，即Infinite Loop。具体细节可以参考[HashMap多线程死循环问题](http://blog.csdn.net/xuefeng0707/article/details/40797085)。因此，不要在并发的环境中同时操作HashMap，这种情况建议使用ConcurrentHashMap。

